const express = require('express')
const http = require('http')
const fs = require('fs')
const puppeteer = require('puppeteer')
const queryString = require('query-string')
const eventEmitter = require('events')


//Express version
const scanxss = express() // Instanciation of Express
const port = 8000

scanxss.get('/', function(req, res) {
  res.sendFile(__dirname +'/static/index.html')
});
scanxss.use(express.static(__dirname+'/static'))

scanxss.listen(port, (err)=> {
  if (err) console.log('Error in server startup');
  console.log(`scanxss app started on port ${port}!`);
});

scanxss.get('/index', async (req, res) => {
  let globalURL = req.query.url;
  console.log('Here you go, The link: '+globalURL);
  let hasXSS = await check_xss(globalURL);
  res.send(hasXSS);
});

// A tab of xss scripts
const XSS_TABSCRIPT = [
  '<script>alert("xss")</script>',
  '<image src=1 href=1 onerror="javascript:alert(1)"></image>',
  "')%3Balert(1)%3Bvar b=('",
  '<iframe onReadyStateChange iframe onReadyStateChange="javascript:javascript:alert(1)"></iframe onReadyStateChange>',
  '<html onMouseOut html onMouseOut="javascript:javascript:alert(1)"></html onMouseOut>',
  '<img src="http://inexist.ent" onerror="javascript:alert(1)"/>',
];

//Verify urls
const check_url = (url, script) => {
  let tempObject = {};
  let newUrl = '';
  //let regex = /\?|^(?:.*\?\/){3}/
  tempObject = url.split('?');
  let tmpParsed = queryString.parse(tempObject[1]);

  let key = Object.keys(tmpParsed);
  if (tempObject[1]) {
    newUrl = tempObject[0] + '?';
    for (let i in tmpParsed) {
      if (key[0] === i) {
        newUrl = newUrl + i + '=' + script;
      } else {
        newUrl = newUrl + '&' + i + '=' + script;
      }
    }
  }
  return newUrl;
};


//
async function check_xss(url) {

    const browser = await puppeteer.launch({
      headless: false,
      // executablePath:
      //   'C:/Program Files (x86)/Google/Chrome/Application/chrome.exe',
      defaultViewport: null,
      args: ['--start-maximized'],
    });
    const page = await browser.newPage();
    await page.goto(url, { waitUntil: 'networkidle2' });
    const formsArray = await page.$$('input');//Equivalent of document.querySelector('input') in javascript
    //console.log(formsArray)
    const page2 = await browser.newPage();
    let isVulnerable = false;
    page2.on('dialog', async (dialog) => {
      isVulnerable = true;
      dialog.accept();
    });
    for (script in XSS_TABSCRIPT) {
      let newUrl = check_url(url, XSS_TABSCRIPT[script]);
      if (newUrl != '') {
        await page2.goto(newUrl);
      }
      if (isVulnerable) {
        browser.close();
        return true;
      }
      for (i in formsArray) {
        try {
          await page2.goto(url, { waitUntil: 'networkidle2', timeout: 60000 });//consider navigation to be finished when there are no more than 2 network connections for at least 500 ms.
          const inputsArray = await formsArray[
            i
          ].$$eval(
            'input[type="text"],input[type="search"],input:not([type]),textarea',
            (inputs) =>
              inputs.map((input) =>
                input.id ? '#' + input.id : '.' + input.className
              )
          );
          for (input in inputsArray) {
            let selector = inputsArray[input];
            if (selector.charAt(0) == '.') {
              selector = selector.split(' ');
            }
            await page2.type(selector, MALICIOUS_SCRIPT[script], { delay: 20 });
          }
          let btnsArray = await formsArray[
            i
          ].$$eval('input[type="submit"],button[type="submit"]', (subs) =>
            subs.map((sub) => (sub.id ? '#' + sub.id : '.' + sub.className))
          );
          let btn = btnsArray[0].split(' ');
          await page2.click(btn);
          newUrl = check_url(page2.url(), MALICIOUS_SCRIPT[script]);
          if (newUrl != '') {
            await page2.goto(newUrl);
          }
        } catch (error) {
          browser.close();
          return error.message;
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 2000));
      if (isVulnerable) {
        browser.close();
        return true;
      }
    }
    browser.close();
    await new Promise((resolve) => setTimeout(resolve, 2000));
    if (!isVulnerable) {
      return false;
    } else {
      return true;
    }

}
